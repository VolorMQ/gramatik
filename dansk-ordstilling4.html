<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Hoved+Ledsætninger — 3 sætninger (подсказка: по 1 в hoved и по 1 в leds)</title>
<style>
:root{
  --bg:#fafafa; --ink:#111827; --line:#e5e7eb;
  --hoved:#dbeafe; --leds:#f3e8ff; --pool-text:#0f172a;
  --blue:#2563eb; --green:#10b981; --amber:#f59e0b; --red:#ef4444;
}
html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5}
.page{max-width:1200px;margin:24px auto;padding:0 16px}
h1{font-size:20px;margin:0 0 12px}
.note{font-size:13px;color:#374151;margin-bottom:10px}
table{width:100%;border-collapse:collapse;border:1px solid var(--line);margin-bottom:12px}
th,td{border:1px solid var(--line);padding:10px;text-align:center;min-height:44px;vertical-align:middle}
th{font-size:12px;text-transform:uppercase;background:#f8fafc}
#legend{display:flex;gap:12px;align-items:center;margin:12px 0}
.legend-item{display:flex;gap:8px;align-items:center;font-size:13px;color:#374151}
.legend-swatch{width:18px;height:18px;border-radius:6px;border:1px solid rgba(0,0,0,0.06)}
.legend-hoved{background:var(--hoved)}
.legend-leds{background:var(--leds)}
#word-pool{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
.word{padding:8px 12px;border-radius:8px;color:var(--pool-text);font-weight:700;cursor:grab;user-select:none}
.pool-hoved{background:var(--hoved);border:1px solid rgba(37,99,235,0.08)}
.pool-leds{background:var(--leds);border:1px solid rgba(139,92,246,0.08)}
#buttons{margin-top:12px;display:flex;gap:8px}
button{padding:8px 14px;background:var(--blue);color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:700}
button:disabled{opacity:0.5;cursor:default}
#translation{margin-top:12px;font-weight:600;color:var(--green)}
.correct{background: #d1fae5 !important}
.partial{background: #fef08a !important}
.wrong{background: #fee2e2 !important}
.info{margin-top:8px;color:#374151;font-size:13px}
</style>
</head>
<body>
<div class="page">
  <h1>Hoved + Ledsætninger (3 sætninger)</h1>
  <div class="note">Перетаскивай слова из пула в пустые ячейки. <strong>Tjek</strong> — проверка, <strong>Hjælp</strong> — вставляет по 1 слову в случайную пустую ячейку каждой части (hoved и leds) для каждой строки, <strong>Nulstil</strong> — новое трио.</div>

  <table aria-label="Hoved + Ledsætninger">
    <thead>
      <tr>
        <th>subjekt</th>
        <th>verbum1</th>
        <th>adverbium</th>
        <th>verbum2-3</th>
        <th>objekt</th>
        <th>sted/tid</th>
        <th>comma</th>
        <th>L-Konjuktion</th>
        <th>subjekt (leds)</th>
        <th>verbum1 (leds)</th>
        <th>verbum2-3 (leds)</th>
        <th>objekt (leds)</th>
        <th>sted/tid (leds)</th>
      </tr>
    </thead>
    <tbody id="sentence-rows"></tbody>
  </table>

  <div id="legend" aria-hidden="false">
    <div class="legend-item"><span class="legend-swatch legend-hoved" aria-hidden="true"></span>Слова из <strong>hovedsætning</strong></div>
    <div class="legend-item"><span class="legend-swatch legend-leds" aria-hidden="true"></span>Слова из <strong>ledsætning</strong></div>
  </div>

  <div id="word-pool" aria-live="polite"></div>

  <div id="buttons">
    <button id="check-button">Tjek</button>
    <button id="hint-button">Hjælp</button>
    <button id="reset-button">Nulstil</button>
  </div>

  <div id="translation"></div>
  <div class="info">Легенда показывает, какие слова в пуле принадлежат к hovedsætning и какие — к ledsætning.</div>
</div>

<script>
/* Скрипт: 3 предложения, подсказка по 1 слову в hoved и 1 слову в leds на строку */
let allSentences = [];
let selectedIdx = [];
let selectedSentences = [];
let wordsMaster = [];
let uidCounter = 1;

fetch('words.json')
  .then(r => r.json())
  .then(d => {
    if(!d || !Array.isArray(d.sentences)) throw new Error('words.json должен содержать массив sentences');
    allSentences = d.sentences;
    pickThreeRandom();
  })
  .catch(err => {
    console.error(err);
    document.body.insertAdjacentHTML('afterbegin', `<div style="color:#b91c1c;padding:12px;">Ошибка загрузки words.json: ${err.message}</div>`);
  });

function shuffle(arr){ return arr.sort(()=>Math.random()-0.5); }

/* безопасный доступ к возможным вариантам имен полей */
function getField(obj, ...keys){
  for(const k of keys) if(obj && (k in obj) && obj[k] && typeof obj[k].word !== 'undefined') return obj[k];
  return { word:'', translation:'' };
}

/* вернуть корректное поле из объекта предложения по логическому ключу */
function getCorrectFieldFrom(sectionObj, logicalKey){
  if(!sectionObj) return {word:'', translation:''};
  switch(logicalKey){
    case 'subjekt': return getField(sectionObj,'subjekt');
    case 'verbum1': return getField(sectionObj,'verbum1','verbium1','verbum1_1','verbium1_1');
    case 'adverbium': return getField(sectionObj,'adverbium','adverbium1');
    case 'verbum2_3': return getField(sectionObj,'verbium2-3','verbum2-3','verbium2_3','verbum2_3');
    case 'objekt': return getField(sectionObj,'objekt');
    case 'stedtid': return getField(sectionObj,'sted/tid','sted_tid','stedtid');
    case 'L-Konjuktion': return getField(sectionObj,'L-Konjuktion','lkonj','L-Konj');
    default: return getField(sectionObj, logicalKey);
  }
}

function pickThreeRandom(){
  if(!allSentences.length) return;
  const indices = Array.from(allSentences.keys());
  shuffle(indices);
  selectedIdx = indices.slice(0, Math.min(3, indices.length));
  selectedSentences = selectedIdx.map(i => allSentences[i]);
  initUI();
}

function initUI(){ uidCounter = 1; buildTable(); buildPool(); renderPool(); clearHighlights(); updateTranslation(); document.getElementById('hint-button').disabled = false; }

function buildTable(){
  const tbody = document.getElementById('sentence-rows'); tbody.innerHTML = '';
  selectedSentences.forEach((s, rowIdx) => {
    const tr = document.createElement('tr'); tr.dataset.row = String(rowIdx);
    const makeCell = (text, fixed, part, key) => {
      const td = document.createElement('td');
      td.dataset.part = part; td.dataset.key = key; td.dataset.row = String(rowIdx);
      if(fixed){ td.textContent = text || ''; td.dataset.uid = 'fixed'; } else { td.textContent = ''; td.dataset.uid = ''; td.addEventListener('dragover', e=>e.preventDefault()); td.addEventListener('drop', e=>dropWord(e, td)); }
      return td;
    };
    const h = s.hovedsætning || {}; const L = s.ledsætning || {};
    tr.appendChild(makeCell(getCorrectFieldFrom(h,'subjekt').word, true, 'hoved', 'subjekt'));
    tr.appendChild(makeCell('', false, 'hoved', 'verbum1'));
    tr.appendChild(makeCell('', false, 'hoved', 'adverbium'));
    tr.appendChild(makeCell('', false, 'hoved', 'verbum2_3'));
    tr.appendChild(makeCell('', false, 'hoved', 'objekt'));
    tr.appendChild(makeCell('', false, 'hoved', 'stedtid'));
    const commaTd = document.createElement('td'); commaTd.textContent = ','; commaTd.dataset.uid = 'fixed'; commaTd.dataset.part='punct'; commaTd.dataset.key='comma'; tr.appendChild(commaTd);
    tr.appendChild(makeCell(getCorrectFieldFrom(L,'L-Konjuktion').word, true, 'leds', 'L-Konjuktion'));
    tr.appendChild(makeCell(getCorrectFieldFrom(L,'subjekt').word, true, 'leds', 'subjekt'));
    tr.appendChild(makeCell('', false, 'leds', 'verbum1'));
    tr.appendChild(makeCell('', false, 'leds', 'verbum2_3'));
    tr.appendChild(makeCell('', false, 'leds', 'objekt'));
    tr.appendChild(makeCell('', false, 'leds', 'stedtid'));
    tbody.appendChild(tr);
  });
}

function buildPool(){
  wordsMaster = [];
  selectedSentences.forEach((s, idx)=>{
    const h = s.hovedsætning||{}; const L = s.ledsætning||{};
    const pushIf = (obj, keys, typeKey, part)=>{
      const f = getField(obj, ...keys);
      if(f && f.word){
        wordsMaster.push({ uid: String(uidCounter++), word: f.word, translation: f.translation||'', typeKey, part, sentenceIndex: idx, inPool: true });
      }
    };
    pushIf(h, ['verbum1','verbium1','verbum1_1','verbium1'], 'verbum1', 'hoved');
    pushIf(h, ['adverbium','adverbium1'], 'adverbium', 'hoved');
    pushIf(h, ['verbium2-3','verbum2-3','verbium2_3','verbium2_3'], 'verbum2_3', 'hoved');
    pushIf(h, ['objekt'], 'objekt', 'hoved');
    pushIf(h, ['sted/tid','sted_tid','stedtid'], 'stedtid', 'hoved');
    pushIf(L, ['verbium1','verbum1','verbium1_1'], 'verbum1', 'leds');
    pushIf(L, ['verbium2-3','verbum2-3','verbium2_3'], 'verbum2_3', 'leds');
    pushIf(L, ['objekt'], 'objekt', 'leds');
    pushIf(L, ['sted/tid','sted_tid','stedtid'], 'stedtid', 'leds');
  });
  wordsMaster = shuffle(wordsMaster);
}

function renderPool(){
  const pool = document.getElementById('word-pool'); pool.innerHTML = '';
  wordsMaster.forEach(w=>{
    if(!w.inPool) return;
    const d = document.createElement('div');
    d.className = 'word ' + (w.part==='hoved' ? 'pool-hoved' : 'pool-leds');
    d.textContent = w.word; d.dataset.uid = w.uid; d.dataset.typeKey = w.typeKey;
    d.draggable = true; d.addEventListener('dragstart', e=> e.dataTransfer.setData('text/plain', w.uid));
    pool.appendChild(d);
  });
}

function findMasterIndexByUid(uid){ return wordsMaster.findIndex(x => String(x.uid) === String(uid)); }

function dropWord(ev, td){
  ev.preventDefault();
  const uid = ev.dataTransfer.getData('text/plain'); const mIdx = findMasterIndexByUid(uid);
  if(mIdx === -1) return;
  const obj = wordsMaster[mIdx];
  const oldUid = td.dataset.uid;
  if(oldUid && oldUid !== 'fixed' && oldUid !== ''){ const oldIdx = findMasterIndexByUid(oldUid); if(oldIdx !== -1) wordsMaster[oldIdx].inPool = true; }
  td.textContent = obj.word; td.dataset.uid = obj.uid; obj.inPool = false;
  renderPool(); clearHighlights(); updateTranslation();
}

function clearHighlights(){ document.querySelectorAll('#sentence-rows td').forEach(td=>td.classList.remove('correct','partial','wrong')); }

document.getElementById('check-button').addEventListener('click', ()=>{
  clearHighlights();
  const rows = Array.from(document.querySelectorAll('#sentence-rows tr'));
  rows.forEach((tr,rowIdx)=>{
    const tds = Array.from(tr.querySelectorAll('td'));
    tds.forEach(td=>{
      const key = td.dataset.key; if(!key) return;
      if(td.dataset.uid === 'fixed'){ td.classList.add('correct'); return; }
      const expectedField = (td.dataset.part==='hoved') ? getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning, td.dataset.key) : getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning, td.dataset.key);
      const expectedWord = expectedField ? (expectedField.word||'') : '';
      const uid = td.dataset.uid; if(!uid){ td.classList.add('wrong'); return; }
      const mIdx = findMasterIndexByUid(uid);
      if(mIdx !== -1){ const w = wordsMaster[mIdx]; if(w.word === expectedWord) td.classList.add('correct'); else if(w.typeKey === td.dataset.key) td.classList.add('partial'); else td.classList.add('wrong'); }
      else { if(td.textContent === expectedWord) td.classList.add('correct'); else td.classList.add('wrong'); }
    });
  });
  updateTranslation();
});

// NEW: подсказка — по 1 слову в случайную пустую ячейку каждой части (hoved и leds) для каждой строки
document.getElementById('hint-button').addEventListener('click', ()=>{
  const rows = Array.from(document.querySelectorAll('#sentence-rows tr'));
  rows.forEach((tr, rowIdx) => {
    // ------- HOVED: выбрать одну случайную пустую ячейку в части 'hoved' и подставить её правильное слово -------
    const emptiesH = Array.from(tr.querySelectorAll('td')).filter(td=>{
      return td.dataset.part==='hoved' && td.dataset.key && td.dataset.uid !== 'fixed' && (!td.dataset.uid || td.dataset.uid === '');
    });
    if(emptiesH.length > 0){
      const tdH = emptiesH[Math.floor(Math.random()*emptiesH.length)];
      const keyH = tdH.dataset.key;
      const correctFieldH = getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning, keyH);
      if(correctFieldH && correctFieldH.word){
        tdH.textContent = correctFieldH.word;
        tdH.dataset.uid = 'fixed';
        // удалить только соответствующую запись из пула: совпадение по слову, part='hoved', sentenceIndex=rowIdx и по typeKey (если возможно)
        const pIdx = wordsMaster.findIndex(w => w.word === correctFieldH.word && w.part === 'hoved' && w.sentenceIndex === rowIdx && w.typeKey === keyH);
        if(pIdx !== -1) wordsMaster[pIdx].inPool = false;
        else {
          // резервный вариант: удалить любой элемент такого слова и части для этой строки
          const pIdx2 = wordsMaster.findIndex(w => w.word === correctFieldH.word && w.part === 'hoved' && w.sentenceIndex === rowIdx);
          if(pIdx2 !== -1) wordsMaster[pIdx2].inPool = false;
        }
      }
    }

    // ------- LEDS: выбрать одну случайную пустую ячейку в части 'leds' и подставить её правильное слово -------
    const emptiesL = Array.from(tr.querySelectorAll('td')).filter(td=>{
      return td.dataset.part==='leds' && td.dataset.key && td.dataset.uid !== 'fixed' && (!td.dataset.uid || td.dataset.uid === '');
    });
    if(emptiesL.length > 0){
      const tdL = emptiesL[Math.floor(Math.random()*emptiesL.length)];
      const keyL = tdL.dataset.key;
      const correctFieldL = getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning, keyL);
      if(correctFieldL && correctFieldL.word){
        tdL.textContent = correctFieldL.word;
        tdL.dataset.uid = 'fixed';
        const pIdxL = wordsMaster.findIndex(w => w.word === correctFieldL.word && w.part === 'leds' && w.sentenceIndex === rowIdx && w.typeKey === keyL);
        if(pIdxL !== -1) wordsMaster[pIdxL].inPool = false;
        else {
          const pIdxL2 = wordsMaster.findIndex(w => w.word === correctFieldL.word && w.part === 'leds' && w.sentenceIndex === rowIdx);
          if(pIdxL2 !== -1) wordsMaster[pIdxL2].inPool = false;
        }
      }
    }
  });

  renderPool();
  updateTranslation();
  // блокируем подсказку после одной такой операции (как было у тебя раньше)
  document.getElementById('hint-button').disabled = true;
});

document.getElementById('reset-button').addEventListener('click', ()=>{
  document.getElementById('hint-button').disabled = false;
  pickThreeRandom();
});

function updateTranslation(){
  const root = document.getElementById('translation'); root.innerHTML = '';
  const rows = Array.from(document.querySelectorAll('#sentence-rows tr'));
  rows.forEach((tr,rowIdx)=>{
    const tds = Array.from(tr.querySelectorAll('td'));
    tds.forEach(td=>{
      const key = td.dataset.key; if(!key) return;
      const uid = td.dataset.uid; let text = td.textContent||'';
      if(uid === 'fixed'){
        const part = td.dataset.part;
        const field = (part==='hoved') ? getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning, key) : getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning, key);
        if(field && field.translation) text += ' → ' + field.translation;
      } else if(uid){
        const mIdx = findMasterIndexByUid(uid);
        if(mIdx !== -1){ const w = wordsMaster[mIdx]; if(w && w.translation) text += ' → ' + w.translation; }
        else {
          const part = td.dataset.part;
          const field = (part==='hoved') ? getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning, key) : getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning, key);
          if(field && field.translation) text += ' → ' + field.translation;
        }
      } else return;
      const d = document.createElement('div'); d.textContent = text; root.appendChild(d);
    });
  });
}
</script>
</body>
</html>
