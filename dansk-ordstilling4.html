<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Hoved+Ledsætninger — 3 sætninger</title>
<style>
:root{
  --bg:#fafafa; --ink:#111827; --line:#e5e7eb;
  --hoved:#dbeafe; --leds:#f3e8ff; --pool-text:#0f172a;
  --blank-bg:#f3f4f6;
  --blue:#2563eb; --green:#10b981; --amber:#f59e0b; --red:#ef4444;
}
html,body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5}
.page{max-width:1200px;margin:24px auto;padding:0 16px}
h1{font-size:20px;margin:0 0 12px}
.note{font-size:13px;color:#374151;margin-bottom:10px}
table{width:100%;border-collapse:collapse;border:1px solid var(--line);margin-bottom:12px}
th,td{border:1px solid var(--line);padding:10px;text-align:center;min-height:44px;vertical-align:middle}
th{font-size:12px;text-transform:uppercase;background:#f8fafc}
#legend{display:flex;gap:12px;align-items:center;margin:12px 0}
.legend-item{display:flex;gap:8px;align-items:center;font-size:13px;color:#374151}
.legend-swatch{width:18px;height:18px;border-radius:6px;border:1px solid rgba(0,0,0,0.06)}
.legend-hoved{background:var(--hoved)}
.legend-leds{background:var(--leds)}
#word-pool{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
.word{padding:8px 12px;border-radius:8px;color:var(--pool-text);font-weight:700;cursor:grab;user-select:none}
.pool-hoved{background:var(--hoved);border:1px solid rgba(37,99,235,0.08)}
.pool-leds{background:var(--leds);border:1px solid rgba(139,92,246,0.08)}
.pool-blank{background:var(--blank-bg);border:1px dashed #9ca3af;color:#6b7280;font-weight:700}
#buttons{margin-top:12px;display:flex;gap:8px}
button{padding:8px 14px;background:var(--blue);color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:700}
button:disabled{opacity:0.5;cursor:default}
#translation{margin-top:12px;font-weight:600;color:var(--green)}
.correct{background: #d1fae5 !important}
.partial{background: #fef08a !important}
.wrong{background: #fee2e2 !important}
.info{margin-top:8px;color:#374151;font-size:13px}
.blank-cell{background:#fff;border:2px dashed #e5e7eb}

/* Mobile tap mode styles */
.tap-mode .word{cursor:pointer;}
.tap-mode td{cursor:pointer;}
</style>
</head>
<body>
<div class="page">
  <h1>Hoved + Ledsætninger (3 sætninger)</h1>

  <label><input type="checkbox" id="mobile-mode"> Mobilversion (tap) вместо drag&drop</label>

  <div class="note">Пул содержит отдельный специальный токен <strong>(blank)</strong>. Перетаскивай слова в пустые ячейки. Если эталон пустой, оставь ячейку пустой или используй <em>blank</em> — при проверке это будет считаться правильным.</div>

  <table aria-label="Hoved + Ledsætninger">
    <thead>
      <tr>
        <th>subjekt</th>
        <th>verbum1</th>
        <th>adverbium</th>
        <th>verbum2-3</th>
        <th>objekt</th>
        <th>sted/tid</th>
        <th>comma</th>
        <th>L-Konjuktion</th>
        <th>subjekt (leds)</th>
        <th>verbum1 (leds)</th>
        <th>verbum2-3 (leds)</th>
        <th>objekt (leds)</th>
        <th>sted/tid (leds)</th>
      </tr>
    </thead>
    <tbody id="sentence-rows"></tbody>
  </table>

  <div id="legend" aria-hidden="false">
    <div class="legend-item"><span class="legend-swatch legend-hoved" aria-hidden="true"></span>Слова из <strong>hovedsætning</strong></div>
    <div class="legend-item"><span class="legend-swatch legend-leds" aria-hidden="true"></span>Слова из <strong>ledsætning</strong></div>
    <div class="legend-item"><span class="legend-swatch pool-blank" style="width:18px;height:18px;border-radius:6px;display:inline-block"></span>Специальный <strong>blank</strong> (пустой) токен</div>
  </div>

  <div id="word-pool" aria-live="polite"></div>

  <div id="buttons">
    <button id="check-button">Tjek</button>
    <button id="hint-button">Hjælp</button>
    <button id="reset-button">Nulstil</button>
  </div>

  <div id="translation"></div>
  <div class="info">Если эталон пустой — оставь ячейку пустой или используй <em>blank</em>. Это будет отмечено как правильно (зелёным).</div>
</div>

<script>
let allSentences = [];
let selectedIdx = [];
let selectedSentences = [];
let wordsMaster = [];
let uidCounter = 1;
let tappedWord = null; // для мобильного режима

fetch('words.json')
  .then(r => r.json())
  .then(d => {
    if(!d || !Array.isArray(d.sentences)) throw new Error('words.json должен содержать массив sentences');
    allSentences = d.sentences;
    pickThreeRandom();
  })
  .catch(err => {
    console.error(err);
    document.body.insertAdjacentHTML('afterbegin', `<div style="color:#b91c1c;padding:12px;">Ошибка загрузки words.json: ${err.message}</div>`);
  });

function shuffle(arr){ return arr.sort(()=>Math.random()-0.5); }
function getField(obj, ...keys){ for(const k of keys) if(obj && (k in obj) && obj[k] && typeof obj[k].word !== 'undefined') return obj[k]; return { word:'', translation:'' }; }
function getCorrectFieldFrom(sectionObj, logicalKey){
  if(!sectionObj) return {word:'', translation:''};
  switch(logicalKey){
    case 'subjekt': return getField(sectionObj,'subjekt');
    case 'verbum1': return getField(sectionObj,'verbum1','verbium1','verbum1_1','verbium1_1');
    case 'adverbium': return getField(sectionObj,'adverbium','adverbium1');
    case 'verbum2_3': return getField(sectionObj,'verbium2-3','verbum2-3','verbum2_3','verbum2_3');
    case 'objekt': return getField(sectionObj,'objekt');
    case 'stedtid': return getField(sectionObj,'sted/tid','sted_tid','stedtid');
    case 'L-Konjuktion': return getField(sectionObj,'L-Konjuktion','lkonj','L-Konj');
    default: return getField(sectionObj, logicalKey);
  }
}

function pickThreeRandom(){
  if(!allSentences.length) return;
  const indices = Array.from(allSentences.keys());
  shuffle(indices);
  selectedIdx = indices.slice(0, Math.min(3, indices.length));
  selectedSentences = selectedIdx.map(i => allSentences[i]);
  initUI();
}

function initUI(){
  uidCounter = 1;
  buildTable();
  buildPool();
  renderPool();
  clearHighlights();
  updateTranslation();
  document.getElementById('hint-button').disabled = false;
}

function buildTable(){
  const tbody = document.getElementById('sentence-rows'); tbody.innerHTML = '';
  selectedSentences.forEach((s, rowIdx) => {
    const tr = document.createElement('tr'); tr.dataset.row = String(rowIdx);
    const makeCell = (text, fixed, part, key) => {
      const td = document.createElement('td');
      td.dataset.part = part; td.dataset.key = key; td.dataset.row = String(rowIdx);
      if(fixed){ td.textContent = text || ''; td.dataset.uid = 'fixed'; }
      else { td.textContent = ''; td.dataset.uid = ''; td.classList.add('blank-cell');
        td.addEventListener('dragover', e=>e.preventDefault());
        td.addEventListener('drop', e=>dropWord(e, td));
        td.addEventListener('click', ()=>tapCell(td));
      }
      return td;
    };
    const h = s.hovedsætning || {}; const L = s.ledsætning || {};

    tr.appendChild(makeCell(getCorrectFieldFrom(h,'subjekt').word, true, 'hoved', 'subjekt'));
    tr.appendChild(makeCell('', false, 'hoved', 'verbum1'));
    tr.appendChild(makeCell('', false, 'hoved', 'adverbium'));
    tr.appendChild(makeCell('', false, 'hoved', 'verbum2_3'));
    tr.appendChild(makeCell('', false, 'hoved', 'objekt'));
    tr.appendChild(makeCell('', false, 'hoved', 'stedtid'));

    const commaTd = document.createElement('td');
    commaTd.textContent = ',';
    commaTd.dataset.uid = 'fixed';
    commaTd.dataset.part = 'punct';
    commaTd.dataset.key = 'comma';
    tr.appendChild(commaTd);

    tr.appendChild(makeCell(getCorrectFieldFrom(L,'L-Konjuktion').word, true, 'leds', 'L-Konjuktion'));
    tr.appendChild(makeCell(getCorrectFieldFrom(L,'subjekt').word, true, 'leds', 'subjekt'));
    tr.appendChild(makeCell('', false, 'leds', 'verbum1'));
    tr.appendChild(makeCell('', false, 'leds', 'verbum2_3'));
    tr.appendChild(makeCell('', false, 'leds', 'objekt'));
    tr.appendChild(makeCell('', false, 'leds', 'stedtid'));

    tbody.appendChild(tr);
  });
}

function buildPool(){
  wordsMaster = [];
  selectedSentences.forEach((s, idx)=>{
    const h = s.hovedsætning||{}; const L = s.ledsætning||{};
    const pushIf = (obj, keys, typeKey, part)=>{
      const f = getField(obj, ...keys);
      if(f && f.word){
        wordsMaster.push({ uid: String(uidCounter++), word: f.word, translation: f.translation||'', typeKey, part, sentenceIndex: idx, inPool: true });
      }
    };
    pushIf(h, ['verbum1','verbium1','verbum1_1','verbum1'], 'verbum1', 'hoved');
    pushIf(h, ['adverbium','adverbium1'], 'adverbium', 'hoved');
    pushIf(h, ['verbium2-3','verbum2-3','verbium2_3'], 'verbum2_3', 'hoved');
    pushIf(h, ['objekt'], 'objekt', 'hoved');
    pushIf(h, ['sted/tid','sted_tid','stedtid'], 'stedtid', 'hoved');
    pushIf(L, ['verbium1','verbum1','verbium1_1'], 'verbum1', 'leds');
    pushIf(L, ['verbium2-3','verbum2-3','verbum2_3'], 'verbum2_3', 'leds');
    pushIf(L, ['objekt'], 'objekt', 'leds');
    pushIf(L, ['sted/tid','sted_tid','stedtid'], 'stedtid', 'leds');
  });
  wordsMaster.push({ uid:'blank', word:'', translation:'', typeKey:'blank', part:'both', sentenceIndex:null, inPool:true, isBlank:true });
  wordsMaster = shuffle(wordsMaster);
}

function renderPool(){
  const pool = document.getElementById('word-pool'); pool.innerHTML = '';
  wordsMaster.forEach(w=>{
    if(!w.inPool) return;
    const d = document.createElement('div');
    if(w.isBlank){
      d.className = 'word pool-blank'; d.textContent='(blank)';
    } else {
      d.className = 'word '+(w.part==='hoved'?'pool-hoved':'pool-leds'); d.textContent = w.word;
    }
    d.dataset.uid = w.uid; d.dataset.typeKey = w.typeKey;
    d.draggable = true;
    d.addEventListener('dragstart', e=> e.dataTransfer.setData('text/plain', w.uid));
    d.addEventListener('click', ()=>tapWord(w));
    pool.appendChild(d);
  });
}

function findMasterIndexByUid(uid){ return wordsMaster.findIndex(x => String(x.uid)===String(uid)); }

function dropWord(ev, td){
  ev.preventDefault();
  const uid = ev.dataTransfer.getData('text/plain');
  const mIdx = findMasterIndexByUid(uid); if(mIdx===-1) return;
  const obj = wordsMaster[mIdx];

  const oldUid = td.dataset.uid;
  if(oldUid && oldUid!=='fixed' && oldUid!=='' && oldUid!=='blank'){
    const oldIdx = findMasterIndexByUid(oldUid); if(oldIdx!==-1) wordsMaster[oldIdx].inPool=true;
  }

  if(obj.isBlank){ td.textContent=''; td.dataset.uid='blank'; }
  else { td.textContent=obj.word; td.dataset.uid=obj.uid; obj.inPool=false; }

  renderPool();
  clearHighlights();
  updateTranslation();
}

function clearHighlights(){ document.querySelectorAll('#sentence-rows td').forEach(td=>td.classList.remove('correct','partial','wrong')); }

document.getElementById('check-button').addEventListener('click', ()=>{
  clearHighlights();
  const rows = Array.from(document.querySelectorAll('#sentence-rows tr'));
  rows.forEach((tr,rowIdx)=>{
    const tds = Array.from(tr.querySelectorAll('td'));
    tds.forEach(td=>{
      const key = td.dataset.key; if(!key) return;
      if(td.dataset.uid==='fixed'){ td.classList.add('correct'); return; }
      const expectedField = (td.dataset.part==='hoved')? getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning, key) : getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning, key);
      const expectedWord = expectedField? (expectedField.word||''):'';
      const uid = td.dataset.uid;
      if(expectedWord===''){ if(!uid || uid==='blank' || td.textContent.trim()==='') td.classList.add('correct'); else td.classList.add('wrong'); return; }
      if(!uid || uid===''){ td.classList.add('wrong'); return; }
      if(uid==='blank'){ td.classList.add('wrong'); return; }
      const mIdx = findMasterIndexByUid(uid); if(mIdx!==-1){
        const w = wordsMaster[mIdx];
        if(w.word===expectedWord) td.classList.add('correct');
        else if(w.typeKey===td.dataset.key) td.classList.add('partial');
        else td.classList.add('wrong');
      } else { if(td.textContent===expectedWord) td.classList.add('correct'); else td.classList.add('wrong'); }
    });
  });
  updateTranslation();
});

document.getElementById('hint-button').addEventListener('click', ()=>{
  const rows = Array.from(document.querySelectorAll('#sentence-rows tr'));
  rows.forEach((tr,rowIdx)=>{
    const emptiesH = Array.from(tr.querySelectorAll('td')).filter(td=>{
      if(td.dataset.part!=='hoved') return false;
      if(!td.dataset.key) return false;
      if(td.dataset.uid==='fixed') return false;
      const expectedFieldH = getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning, td.dataset.key);
      if(!expectedFieldH || (expectedFieldH.word||'')==='') return false;
      return !td.dataset.uid || td.dataset.uid==='';
    });
    if(emptiesH.length>0){
      const tdH = emptiesH[Math.floor(Math.random()*emptiesH.length)];
      const keyH = tdH.dataset.key;
      const correctFieldH = getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning,keyH);
      if(correctFieldH && correctFieldH.word){
        tdH.textContent = correctFieldH.word;
        tdH.dataset.uid='fixed';
        const pIdx = wordsMaster.findIndex(w=>!w.isBlank && w.word===correctFieldH.word && w.part==='hoved' && w.sentenceIndex===rowIdx && w.typeKey===keyH);
        if(pIdx!==-1) wordsMaster[pIdx].inPool=false;
      }
    }
    const emptiesL = Array.from(tr.querySelectorAll('td')).filter(td=>{
      if(td.dataset.part!=='leds') return false;
      if(!td.dataset.key) return false;
      if(td.dataset.uid==='fixed') return false;
      const expectedFieldL = getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning, td.dataset.key);
      if(!expectedFieldL || (expectedFieldL.word||'')==='') return false;
      return !td.dataset.uid || td.dataset.uid==='';
    });
    if(emptiesL.length>0){
      const tdL = emptiesL[Math.floor(Math.random()*emptiesL.length)];
      const keyL = tdL.dataset.key;
      const correctFieldL = getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning,keyL);
      if(correctFieldL && correctFieldL.word){
        tdL.textContent = correctFieldL.word;
        tdL.dataset.uid='fixed';
        const pIdxL = wordsMaster.findIndex(w=>!w.isBlank && w.word===correctFieldL.word && w.part==='leds' && w.sentenceIndex===rowIdx && w.typeKey===keyL);
        if(pIdxL!==-1) wordsMaster[pIdxL].inPool=false;
      }
    }
  });
  renderPool();
  updateTranslation();
  document.getElementById('hint-button').disabled=false;
});

document.getElementById('reset-button').addEventListener('click', ()=>{ pickThreeRandom(); document.getElementById('hint-button').disabled=false; });

function updateTranslation(){
  const root = document.getElementById('translation'); root.innerHTML='';
  const rows = Array.from(document.querySelectorAll('#sentence-rows tr'));
  rows.forEach((tr,rowIdx)=>{
    const tds = Array.from(tr.querySelectorAll('td'));
    tds.forEach(td=>{
      const key = td.dataset.key; if(!key) return;
      const uid = td.dataset.uid; let text=td.textContent||'';
      if(uid==='fixed'){
        const part = td.dataset.part;
        const field = (part==='hoved') ? getCorrectFieldFrom(selectedSentences[rowIdx].hovedsætning,key) : getCorrectFieldFrom(selectedSentences[rowIdx].ledsætning,key);
        if(field && field.translation) text+=' → '+field.translation;
      } else if(uid){
        if(uid==='blank'){}
        else{ const mIdx=findMasterIndexByUid(uid); if(mIdx!==-1){ const w=wordsMaster[mIdx]; if(w&&w.translation) text+=' → '+w.translation; } }
      } else return;
      if(text){ const d=document.createElement('div'); d.textContent=text; root.appendChild(d); }
    });
  });
}

/* --- Mobile tap functionality --- */
document.getElementById('mobile-mode').addEventListener('change', e=>{
  if(e.target.checked) document.body.classList.add('tap-mode');
  else { document.body.classList.remove('tap-mode'); tappedWord=null; }
});

function tapWord(wordObj){
  if(!document.body.classList.contains('tap-mode')) return;
  tappedWord = wordObj;
}

function tapCell(td){
  if(!document.body.classList.contains('tap-mode')) return;
  if(!tappedWord) return;
  const obj = tappedWord;
  const oldUid = td.dataset.uid;
  if(oldUid && oldUid!=='fixed' && oldUid!=='' && oldUid!=='blank'){
    const oldIdx = findMasterIndexByUid(oldUid); if(oldIdx!==-1) wordsMaster[oldIdx].inPool=true;
  }
  if(obj.isBlank){ td.textContent=''; td.dataset.uid='blank'; }
  else { td.textContent=obj.word; td.dataset.uid=obj.uid; obj.inPool=false; }
  tappedWord=null;
  renderPool();
  clearHighlights();
  updateTranslation();
}
</script>
</body>
</html>
